import * as Framer from "framer"; import * as React from "react"; import {
createPortal } from "react-dom"; import * as ReactDOM from "react-dom/client";
const routes = {augiA20Il: {elements: {CKK0Mr083: "scroll-1", dH45YVLc_:
"community-desktop", Hx8gTri59: "ptai-section", iGvAZTwZU: "faq-desktop",
kcKmZplQu: "ptaisoon-1", kqrxaCKNv: "features-1", kr2UYWwep: "community-tab",
M8_vjpK9Y: "ptai-desktop", nAOwo3FWF: "partners-desktop", NOmTRbXmg:
"road-map-2", pIM2rduYZ: "community", rPKLrUFs2ECyrphIpP: "ptai",
rPKLrUFs2ITsCqBsY5: "community-mobile", rPKLrUFs2J15HghyCm: "ptaisoon",
rPKLrUFs2JODUP_0KK: "road-map-1", rPKLrUFs2KJXZ6dVK2: "faq-tab",
rPKLrUFs2Lrio4GvYo: "road-map", rPKLrUFs2Nraj3NXCn: "scroll",
rPKLrUFs2RqX3LIb1v: "ptai-mobile", rPKLrUFs2sk41soMSV: "features",
rPKLrUFs2vkIMn1KLX: "features-tab", ZNPcImssG: "features-desktop", Zp77vsytW:
"road-map-desktop"}, page: Framer.lazy(() =>
import("/framerusercontent.com/modules/pMJFIz8GZN9LbxZCO8wy/PdTe8y6DbRVwKuvnmXQC/augiA20Il.js")),
path: "/"}, RvVyxhNbr: {elements: {Ak0_z6W0Z: "road-map", BDhUOq44U: "ptai",
lVKS_onw4: "faq", ZyJw6okeb: "features"}, page: Framer.lazy(() =>
import("/framerusercontent.com/modules/kzfw7n9D2IVaP5qfTFXQ/b8CJU3BtuaEQXhLY6Ati/RvVyxhNbr.js")),
path: "/home"}, Ito3uObmv: {elements: {BvBJapyLb: "road-map", c1tKgiVEp: "faq",
DXDCzZTUb: "features", pFQHExd_L: "ptai"}, page: Framer.lazy(() =>
import("/framerusercontent.com/modules/sGwUxFyurqdVtTH9TWV0/B9DUTE2TCBhibjq1QM4l/Ito3uObmv.js")),
path: "/response"}, V7eW0cP4R: {elements: {aoOFSz_hr: "terms-and-conditions-1",
BW7EYYMuG: "ptai", FBJ_l4yPI: "road-map", fIBTkCddQ: "features", hNR13jMSI:
"privacy-notice-mobile", OcDRAxlmd: "terms-and-conditions", uMJvZ1Eiu: "scroll",
Uz3TM9tcP: "terms-and-conditions-mobile"}, page: Framer.lazy(() =>
import("/framerusercontent.com/modules/YUTuiwLN5lyZopHyqQwK/90ZSexo6qrUeBHuw4dm5/V7eW0cP4R.js")),
path: "/terms"}, TnoBgkQ2o: {elements: {ah8gxIawZ: "road-map", H8cVAJdCB:
"ptai", MXPoHOf9l: "scroll", nZy9H5yVj: "privacy-notice-1", oKD7LaPWx:
"privacy-notice-mobile", RGJbxgHFD: "terms-and-conditions-mobile", S6IgwIAzh:
"privacy-notice", uwAKu19BG: "features"}, page: Framer.lazy(() =>
import("/framerusercontent.com/modules/n5rSHldR1Va4KaCc9akG/6gJsjwlUVNiI1QklOuZg/TnoBgkQ2o.js")),
path: "/privacy"}, LgJKf7UmP: {elements: {eBpO8rL59: "terms-and-conditions",
GtVrMnITs: "privacy-notice-mobile", lDdcnT8cl: "ptai", mCS4uH888:
"terms-and-conditions-mobile", ofrH9WQAt: "road-map", uAmQ5G6wU: "features",
UEhaqEcsy: "scroll", YQyBRWTiy: "privacy-notice"}, page: Framer.lazy(() =>
import("/framerusercontent.com/modules/k6EOVzuCFlcTqpjRBiTW/Ea8fv7m7EMNA0DgPfZ43/LgJKf7UmP.js")),
path: "/privacy-dup"}} const locales = [{code: "en-US", id: "default", name:
"English", slug: ""}] const collectionUtils = {} const framerSiteId =
"cd18f0c502d829b72da5c6a3e38d10554a1ac8b9e957478778c6021399b0b7d4" export async
function getPageRoot({ routeId, pathVariables, localeId }) { const rootPreload =
routes[routeId].page.preload() const content = React.createElement(
Framer.PageRoot, { isWebsite: true, routeId, pathVariables, routes,
collectionUtils, framerSiteId, notFoundPage: Framer.lazy(() =>
import("__framer-not-found-page")), isReducedMotion: undefined, localeId,
locales, preserveQueryParams: undefined, siteCanonicalURL:
"https://www.babygrokai.org", EditorBar: typeof window === "undefined" ? undefined :
(() => { const isBot =
/bot|-google|google-|yandex|ia_archiver|crawl|spider/iu.test(navigator.userAgent)
if (isBot) return return Framer.lazy(async () => { const { createEditorBar } =
await import("https://edit.framer.com/init.mjs") return { default:
createEditorBar({ dependencies: { __version: 1, framer: { useCurrentRoute:
Framer.useCurrentRoute, useLocaleInfo: Framer.useLocaleInfo, useRouter:
Framer.useRouter, }, react: { createElement: React.createElement, memo:
React.memo, useCallback: React.useCallback, useEffect: React.useEffect, useRef:
React.useRef, useState: React.useState, }, "react-dom": { createPortal }, }, }),
} }) })() , } ) const contentWithFeaturesContext = React.createElement(
Framer.LibraryFeaturesProvider, { children: content, value:
{editorBarDisableFrameAncestorsSecurity: false, editorBarOnPageEditing: false,
motionDivToDiv: false, pauseOffscreen: true, replaceNestedLinks: true,
yieldOnTap: false} } ) const contentWithGracefullyDegradingErrorBoundary =
React.createElement(Framer.GracefullyDegradingErrorBoundary, { children:
contentWithFeaturesContext }) const page =
React.createElement(Framer.PageEffectsProvider, { children:
contentWithGracefullyDegradingErrorBoundary, value: {routes: {}} }) // We don't
want the initial render to immediately have to suspend. await rootPreload return
page } const isBrowser = typeof document !== "undefined" if (isBrowser) {
window.__framer_importFromPackage = (packageAndFilename, exportIdentifier) => ()
=> { return React.createElement(Framer.ErrorPlaceholder, { error: 'Package
component not supported: "' + exportIdentifier + '" in "' + packageAndFilename +
'"' }) } // A lot of libraries assume process.env.NODE_ENV is present in
runtime/buildtime, so we are polyfilling it window.process = {
...window.process, env: { ...(window.process ? window.process.env: undefined),
NODE_ENV: "production" } } window.__framer_events = window.__framer_events || []
// Fallback support for stack gaps Framer.installFlexboxGapWorkaroundIfNeeded()
const container = document.getElementById("main") // We know that #main is
parsed before this script, so we don't need to wait for DOMContentLoaded or
similar events. if ("framerHydrateV2" in container.dataset) main(true,
container) else main(false, container) } function track() { if (!isBrowser)
return window.__framer_events.push(arguments) } async function
main(shouldHydrate, container) { function handleError(error, errorInfo,
recoverable = true) { if (error.caught || window.__framer_hadFatalError) return
// we already logged it const componentStack = errorInfo?.componentStack if
(recoverable) { console.warn("Recoverable error has happened. Please check any
custom code or code overrides to fix server/client mismatches:\n", error,
componentStack) // we only want to collect 1%, because this can be quite noisy
(floods the data pipeline) if (Math.random() > 0.01) return } else {
console.error("Fatal crash has happened. If you are the author of this website,
please report this issue to the Framer team via
https://www.framer.community/:\n", error, componentStack) } track(recoverable ?
"published_site_load_recoverable_error" : "published_site_load_error", {
message: String(error), componentStack, // componentStack is more useful stack:
componentStack ? undefined : error instanceof Error && typeof error.stack ===
"string" ? error.stack : null, }) } try { let routeId, localeId, pathVariables,
breakpoints if (shouldHydrate) { const routeData =
JSON.parse(container.dataset.framerHydrateV2) routeId = routeData.routeId
localeId = routeData.localeId pathVariables = routeData.pathVariables
breakpoints = routeData.breakpoints routeId =
Framer.patchRoutesForABTesting(routes, routeId) // Prioritize optimized route id
to avoid flickering in browsers not supporting the server-timing header (Safari
older than 16.4) } else { Framer.patchRoutesForABTesting(routes, undefined) //
This must happen before inferInitialRouteFromPath const routeData =
Framer.inferInitialRouteFromPath(routes, decodeURIComponent(location.pathname),
true, locales) routeId = routeData.routeId localeId = routeData.localeId
pathVariables = routeData.pathVariables } const pagePromise = getPageRoot({
routeId, localeId, pathVariables }) if (typeof window !== "undefined") { void
(async () => { const route = routes[routeId] const defaultLocaleId = "default"
const framerLocale = locales.find(({ id }) => !localeId ? id === defaultLocaleId
: id === localeId).code let collectionItemId = null if (route?.collectionId &&
collectionUtils) { const utils = await collectionUtils[route.collectionId]?.()
const [slug] = Object.values(pathVariables) if (utils && typeof slug ===
"string") { collectionItemId = (await utils.getRecordIdBySlug(slug, framerLocale
|| undefined)) ?? null } } const resolvedDateTimeOptions =
Intl.DateTimeFormat().resolvedOptions() const timezone =
resolvedDateTimeOptions.timeZone const locale = resolvedDateTimeOptions.locale
// wait for the page to be activated before sending the pageview event //
https://developer.chrome.com/docs/web-platform/prerender-pages#impact-on-analytics
await new Promise((resolve) => { if (document.prerendering) {
document.addEventListener("prerenderingchange", resolve, { once: true }) } else
{ resolve() } }) window.__framer_events.push([ "published_site_pageview", {
framerSiteId: framerSiteId ?? null, routePath: route?.path || "/",
collectionItemId, framerLocale: framerLocale || null, webPageId:
route?.abTestingVariantId ?? routeId, abTestId: route?.abTestId, referrer:
document.referrer || null, url: window.location.href, hostname:
window.location.hostname || null, pathname: window.location.pathname || null,
hash: window.location.hash || null, search: window.location.search || null,
timezone, locale, }, "eager" ]) // Yield to avoid blocking the main thread with
the user code await Framer.yieldToMain({ priority: "background",
ensureContinueBeforeUnload: true, continueAfter: "paint" })
document.dispatchEvent(new CustomEvent("framer:pageview", { detail: {
framerLocale: framerLocale || null } })) })() } const page = await pagePromise
if (shouldHydrate) { Framer.withPerformanceMarks("framer-rewrite-breakpoints",
() => { Framer.removeHiddenBreakpointLayersV2(breakpoints)
window.__framer_onRewriteBreakpoints?.(breakpoints) }) const startTransition =
React.startTransition startTransition(() => { Framer.markHydrationStart() if
(true) Framer.turnOffReactEventHandling() ReactDOM.hydrateRoot(container, page,
{ onRecoverableError: handleError }) }) } else { ReactDOM.createRoot(container,
{ onRecoverableError: handleError }).render(page) } } catch (error) {
handleError(error, undefined, false) throw error } }
